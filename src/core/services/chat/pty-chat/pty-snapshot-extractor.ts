// src/core/services/chat/pty-chat/pty-snapshot-extractor.ts
import { v4 as uuidv4 } from "uuid";
import type { ChatMessage } from "../chat-session-repository.js";

/**
 * Extracts chat messages from CLI model terminal snapshots.
 * Based on the tested cli-chat-extractor.ts implementation.
 *
 * - Detects user and model messages using explicit terminal markers:
 *   - User start: /^(?:\x1b\[[0-9;:]*m)*>\x1b\[0m /
 *   - Model start: /^(?:\x1b\[[0-9;:]*m)*⏺\x1b\[0m/
 * - Preserves all ASCII/ANSI sequences in message content
 * - Messages may not be pairs; extractor emits sequence as found
 *
 * Core Responsibilities:
 * The extractor should be able to parse a snapshot and identify:
 * 1.  **Welcome Message:** The initial output from the agent upon starting.
 * 2.  **User Messages:** Prompts submitted by the user to the agent.
 * 3.  **Model Messages:** Responses generated by the agent.
 * 4.  **In-Agent Commands:** Special commands like `/clear` that might reset state.
 * 5.  **Exit Signals:** Output indicating the agent session has ended.
 * 6.  **Tool Calls & Results:** Structured blocks for tool execution requests
 *     and the corresponding results.
 *
 * Future Enhancement Cases to Handle:
 * 1.  **Interleaved Non-Agent Commands:** The snapshot may contain standard
 *     shell commands and their output between agent messages. The extractor
 *     must successfully ignore these blocks and only parse lines with the
 *     explicit user (>) or model (⏺) markers.
 *     Example:
 *       > User Prompt 1
 *       ⏺ Model Response 1
 *       $ ls -la
 *       total 0
 *       drwxr-xr-x 1 user user 0 Oct 6 10:00 .
 *       > User Prompt 2
 *
 * 2.  **Multiple Agent Sessions:** A single snapshot could contain several distinct
 *     agent sessions. The current implementation will merge them into a single
 *     list. A future version might need to identify the boundaries (e.g., via
 *     a `cli:newSession` system message) and partition the messages accordingly.
 *
 * 3.  **Corrupted/Partial Markers:** Input streams can be interrupted. The
 *     extractor should be resilient to partial or malformed markers at the
 *     beginning or end of the snapshot.
 *
 * 4.  **Content After Screen Clear:** If a `cli:screenRefresh` event occurs,
 *     the text following it is a completely new screen buffer. The extractor
 *     itself doesn't need to handle this, but the merging logic in the
 *     PtyChatSession depends on the extractor correctly parsing the new content
 *     as a fresh set of messages.
 */

type Role = "user" | "assistant";

// Combined start-marker regex (multiline):
// - Optional ANSI prefix: (?:\x1b\[[0-9;:]*m)*
// - Marker group captures either ">\x1b[0m " or "⏺\x1b[0m"
// - Anchored to line start: ^ with m-flag
const START_RE: RegExp = new RegExp(
  String.raw`^(?:\x1b\[[0-9;:]*m)*(?<marker>>\x1b\[0m |⏺\x1b\[0m)`,
  "gm",
);

function roleFromMarker(marker: string): Role {
  // Marker includes the exact terminal char and reset: ">\x1b[0m " or "⏺\x1b[0m"
  return marker.startsWith(">") ? "user" : "assistant";
}

export function extractMessages(snapshot: string): ChatMessage[] {
  if (!snapshot || snapshot.trim().length === 0) {
    return [];
  }

  const messages: ChatMessage[] = [];
  const indices: Array<{ index: number; marker: string }> = [];

  // Find all start markers with their absolute indices
  for (
    let m = START_RE.exec(snapshot);
    m !== null;
    m = START_RE.exec(snapshot)
  ) {
    const idx = m.index;
    const marker = m.groups?.marker ?? "";
    indices.push({ index: idx, marker });
  }

  if (indices.length === 0) return messages;

  // Build message slices from each start to the next start (or EOF)
  for (let i = 0; i < indices.length; i++) {
    const start = indices[i];
    const end = i + 1 < indices.length ? indices[i + 1].index : snapshot.length;
    const chunk = snapshot.slice(start.index, end);

    messages.push({
      id: uuidv4(),
      message: {
        role: roleFromMarker(start.marker),
        content: chunk,
      },
      metadata: {
        timestamp: new Date(),
      },
    });
  }

  return messages;
}
