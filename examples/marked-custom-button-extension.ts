// examples/marked-custom-button-extension.ts

import { marked, type Token, type Tokens } from "marked";

/**
 * Define a custom token type for our button.
 * This extends the generic token and adds our own properties.
 */
export interface CustomButtonToken extends Tokens.Generic {
  type: "customButton"; // Unique type for our token
  raw: string; // Raw text (less relevant here as we add it programmatically)
  action: string; // The action associated with the button
}

/**
 * This function is called for each token by `walkTokens`.
 * It modifies the token stream to add a custom button to each todo list item.
 */
function addCustomButton(token: Token) {
  if (token.type === "list_item" && token.tokens) {
    // Manually handle `- []` format, which marked doesn't see as a task.
    if (!token.task && token.text.startsWith("[] ")) {
      token.task = true;
      token.checked = false;
      token.text = token.text.substring(3);

      const firstToken = token.tokens[0];
      if (firstToken?.type === "text" && firstToken.text.startsWith("[] ")) {
        const textToken = firstToken as Tokens.Text;
        textToken.text = textToken.text.substring(3);
        textToken.raw = textToken.raw.substring(3);
      }
    }

    // If it's a task item (standard or custom), add the button.
    if (token.task) {
      const customButtonToken: CustomButtonToken = {
        type: "customButton",
        raw: "", // Not parsed from source
        action: "launch-todo",
      };

      // Find the index of a nested list
      const nestedListIndex = token.tokens.findIndex((t) => t.type === "list");

      if (nestedListIndex !== -1) {
        // If a nested list exists, insert the button before it
        token.tokens.splice(nestedListIndex, 0, customButtonToken);
      } else {
        // Otherwise, append it to the end
        token.tokens.push(customButtonToken);
      }
    }
  }
}

/**
 * A utility function to walk through tokens generated by `marked.lexer()`
 * and apply custom processing.
 * @param tokens An array of tokens.
 */
function walkTokens(tokens: Token[]) {
  marked.walkTokens(tokens, addCustomButton);
}

// --- DEMONSTRATION ---

const markdown = `
# Todo List

- [ ] A regular todo item
- [] An item with no space in brackets
    - [ ] A regular todo item
    - [ ] A regular todo item
- [x] A completed todo item
`;

console.log("=== Testing custom token injection ===");
console.log("\nInput Markdown:");
console.log(markdown);

console.log("\n=== marked.lexer() Token Structure (before walkTokens) ===");
const tokens = marked.lexer(markdown);
// Create a deep copy for comparison
const originalTokens = JSON.parse(JSON.stringify(tokens));
console.log(JSON.stringify(originalTokens, null, 2));

// Modify the tokens using our utility
walkTokens(tokens);

console.log("\n=== Full Token Structure (after walkTokens) ===");
console.log(JSON.stringify(tokens, null, 2));

// --- Custom Plain Text Renderer ---

/**
 * Renders tokens into a plain text string, using the token's 'raw' property
 * for most tokens, but providing special rendering for custom ones.
 * @param tokens The array of tokens to render.
 * @returns The rendered plain text string.
 */
function renderToPlainText(tokens: ReadonlyArray<Token>): string {
  let output = "";
  for (const token of tokens) {
    if (token.type === "customButton") {
      output += "<button>custom-button</button>";
    } else if (token.type === "list") {
      output += renderToPlainText(token.items);
    } else if (token.type === "list_item") {
      let content = "";
      if (token.tokens) {
        for (let i = 0; i < token.tokens.length; i++) {
          const t = token.tokens[i];
          const next_t = token.tokens[i + 1];

          // Handle the specific case where a text token with a newline is followed by our button
          if (
            t.type === "text" &&
            t.raw.endsWith("\n") &&
            next_t &&
            next_t.type === "customButton"
          ) {
            content += t.raw.slice(0, -1); // text without newline
            content += renderToPlainText([next_t]); // button
            content += "\n"; // newline
            i++; // skip next token since we've processed it
          } else {
            content += renderToPlainText([t]);
          }
        }
      }

      const textStartIndex = token.raw.indexOf(token.text);
      if (textStartIndex !== -1) {
        const prefix = token.raw.substring(0, textStartIndex);
        const suffix = token.raw.substring(textStartIndex + token.text.length);
        output += prefix + content + suffix;
      } else {
        // Fallback for when text and raw don't match (e.g., indentation differences).
        const prefixMatch = token.raw.match(/^(\s*[-*+]\s+\[.*?\]\s)/);
        const prefix = prefixMatch ? prefixMatch[0] : "";
        output += prefix + content;
        if (token.raw.endsWith("\n") && !output.endsWith("\n")) {
          output += "\n";
        }
        // throw new Error(
        //   `Could not find text in raw for token: ${JSON.stringify(token)}`,
        // );
      }
    } else {
      output += token.raw;
    }
  }
  return output;
}

console.log("\n=== Rendering to plain text with custom button ===");
const plainTextOutput = renderToPlainText(tokens);
console.log(plainTextOutput);
